name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write       # create release
  packages: write       # push GHCR images

jobs:
  api-release:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: spark-api
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive metadata
        id: meta
        run: |
          echo "owner=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_OUTPUT
          echo "version=${GITHUB_REF_NAME}"        >> $GITHUB_OUTPUT
          echo "sha=${GITHUB_SHA}"                 >> $GITHUB_OUTPUT

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push API image
        uses: docker/build-push-action@v6
        with:
          context: ./api
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.meta.outputs.owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.sha }}
            ${{ env.REGISTRY }}/${{ steps.meta.outputs.owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.meta.outputs.version }}" --generate-notes || \
          gh release edit   "${{ steps.meta.outputs.version }}" --notes-start-tag "${{ steps.meta.outputs.version }}"

  deploy:
    name: Deploy via SSH (Compose host)
    needs: api-release
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Derive release vars
        id: meta
        run: |
          echo "TAG=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          echo "OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_OUTPUT

      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Add host to known_hosts
        run: |
          ssh-keyscan -H "${{ secrets.DEPLOY_HOST }}" >> ~/.ssh/known_hosts

      - name: Remote deploy (update IMAGE_TAG and restart api)
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          TAG: ${{ steps.meta.outputs.TAG }}
          OWNER: ${{ steps.meta.outputs.OWNER }}
        run: |
          ssh "${DEPLOY_USER}@${DEPLOY_HOST}" bash -s <<'EOSH'
          set -euo pipefail
          cd "${DEPLOY_PATH}"

          # Previous deployed tag (defaults to 'latest' if missing)
          PREV_TAG="latest"
          if [ -f .env ] && grep -q '^IMAGE_TAG=' .env; then
            PREV_TAG=$(grep '^IMAGE_TAG=' .env | cut -d= -f2-)
          fi
          echo "Previous tag: ${PREV_TAG}"

          # Optional: GHCR login for pulling private images
          if [ -n "${GHCR_PAT:-}" ] && [ -n "${GHCR_USERNAME:-}" ]; then
            echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
          fi

          # Atomically set OWNER and new IMAGE_TAG
          touch .env
          if grep -q '^OWNER=' .env; then sed -i "s/^OWNER=.*/OWNER=${OWNER}/" .env; else echo "OWNER=${OWNER}" >> .env; fi
          if grep -q '^IMAGE_TAG=' .env; then sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=${TAG}/" .env; else echo "IMAGE_TAG=${TAG}" >> .env; fi

          # Deploy new version
          docker compose pull api
          docker compose up -d api
          docker compose ps api

          # Health check with retries (≈60s)
          ok=0
          for i in $(seq 1 20); do
            if curl -sf http://localhost:8080/health >/dev/null; then ok=1; break; fi
            sleep 3
          done

          # Auto-rollback on failure
          if [ "$ok" -ne 1 ]; then
            echo "❌ Health check failed. Rolling back to ${PREV_TAG}..."
            if grep -q '^IMAGE_TAG=' .env; then sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=${PREV_TAG}/" .env; else echo "IMAGE_TAG=${PREV_TAG}" >> .env; fi
            docker compose pull api
            docker compose up -d api
            docker compose ps api
            # Exit non-zero so the CI shows a failed deploy (Slack failure job will notify)
            exit 32
          fi

          echo "✅ Deploy healthy."
          EOSH

  slack-deploy-failure:
    name: Slack notify (deploy failed)
    needs: deploy
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Post Slack failure message
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          if [ -z "${SLACK_WEBHOOK}" ]; then
            echo "No SLACK_WEBHOOK configured; skipping failure notify."
            exit 0
          fi
          payload=$(cat <<JSON
          {
            "text": ":warning: *${REPO}* deploy of *${TAG}* failed health check and was auto-rolled back. Investigate CI logs & Grafana."
          }
          JSON
          )
          curl -s -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK" >/dev/null

  slack-release:
    name: Slack notify
    needs: [api-release, deploy]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
      - name: Post to Slack (Incoming Webhook)
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          if [ -z "${SLACK_WEBHOOK}" ]; then
            echo "No SLACK_WEBHOOK set; skipping Slack notify."
            exit 0
          fi
          payload=$(cat <<JSON
          {
            "text": ":rocket: *${REPO}* deployed *${TAG}* to *production*.\n• Release: https://github.com/${REPO}/releases/tag/${TAG}\n• Image: ghcr.io/${REPO%/*}/spark-api:${TAG}"
          }
          JSON
          )
          curl -s -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK" >/dev/null


