name: Release

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write       # create release
  packages: write       # push GHCR images

jobs:
  notify-start:
    name: Slack notify (start)
    runs-on: ubuntu-latest
    outputs:
      channel: ${{ steps.out.outputs.channel }}
      thread_ts: ${{ steps.out.outputs.thread_ts }}
    steps:
      - name: Post Slack start (thread root)
        id: post
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          if [ -z "${SLACK_BOT_TOKEN}" ] || [ -z "${SLACK_CHANNEL_ID}" ]; then
            echo "No Slack bot token/channel; skipping threaded start message."
            echo "channel=" >> $GITHUB_OUTPUT
            echo "thread_ts=" >> $GITHUB_OUTPUT
            exit 0
          fi
          body=$(jq -n --arg ch "$SLACK_CHANNEL_ID" --arg t ":rocket: *$REPO* releasing *$TAG*…" '{channel:$ch,text:$t,unfurl_links:false}')
          resp=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$body")
          ok=$(echo "$resp" | jq -r '.ok')
          if [ "$ok" != "true" ]; then echo "Slack post failed: $resp"; exit 0; fi
          channel=$(echo "$resp" | jq -r '.channel')
          ts=$(echo "$resp" | jq -r '.ts')
          echo "channel=$channel"   >> $GITHUB_OUTPUT
          echo "thread_ts=$ts"      >> $GITHUB_OUTPUT

      - name: Expose outputs
        id: out
        run: |
          echo "channel=${{ steps.post.outputs.channel }}"  >> $GITHUB_OUTPUT
          echo "thread_ts=${{ steps.post.outputs.thread_ts }}" >> $GITHUB_OUTPUT
  api-release:
    runs-on: ubuntu-latest
    env:
      IMAGE_NAME: spark-api
      REGISTRY: ghcr.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive metadata
        id: meta
        run: |
          echo "owner=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_OUTPUT
          echo "version=${GITHUB_REF_NAME}"        >> $GITHUB_OUTPUT
          echo "sha=${GITHUB_SHA}"                 >> $GITHUB_OUTPUT

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build & push API image
        uses: docker/build-push-action@v6
        with:
          context: ./api
          platforms: linux/amd64
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.meta.outputs.owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.sha }}
            ${{ env.REGISTRY }}/${{ steps.meta.outputs.owner }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ steps.meta.outputs.version }}" --generate-notes || \
          gh release edit   "${{ steps.meta.outputs.version }}" --notes-start-tag "${{ steps.meta.outputs.version }}"

  deploy:
    name: Deploy via SSH (Compose host)
    needs: [notify-start, api-release]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Derive release vars
        id: meta
        run: |
          echo "TAG=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          echo "OWNER=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_OUTPUT

      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      - name: Add host to known_hosts
        run: |
          ssh-keyscan -H "${{ secrets.DEPLOY_HOST }}" >> ~/.ssh/known_hosts

      - name: Remote deploy (update IMAGE_TAG and restart api)
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          TAG: ${{ steps.meta.outputs.TAG }}
          OWNER: ${{ steps.meta.outputs.OWNER }}
        run: |
          ssh "${DEPLOY_USER}@${DEPLOY_HOST}" bash -s <<'EOSH'
          set -euo pipefail
          cd "${DEPLOY_PATH}"

          # Previous deployed tag (defaults to 'latest' if missing)
          PREV_TAG="latest"
          if [ -f .env ] && grep -q '^IMAGE_TAG=' .env; then
            PREV_TAG=$(grep '^IMAGE_TAG=' .env | cut -d= -f2-)
          fi
          echo "Previous tag: ${PREV_TAG}"

          # Optional: GHCR login for pulling private images
          if [ -n "${GHCR_PAT:-}" ] && [ -n "${GHCR_USERNAME:-}" ]; then
            echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USERNAME" --password-stdin
          fi

          # Atomically set OWNER and new IMAGE_TAG
          touch .env
          if grep -q '^OWNER=' .env; then sed -i "s/^OWNER=.*/OWNER=${OWNER}/" .env; else echo "OWNER=${OWNER}" >> .env; fi
          if grep -q '^IMAGE_TAG=' .env; then sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=${TAG}/" .env; else echo "IMAGE_TAG=${TAG}" >> .env; fi

          # Deploy new version
          docker compose pull api
          docker compose up -d api
          docker compose ps api

          # Health check with retries (≈60s)
          ok=0
          for i in $(seq 1 20); do
            if curl -sf http://localhost:8080/health >/dev/null; then ok=1; break; fi
            sleep 3
          done

          # Auto-rollback on failure
          if [ "$ok" -ne 1 ]; then
            echo "❌ Health check failed. Rolling back to ${PREV_TAG}..."
            if grep -q '^IMAGE_TAG=' .env; then sed -i "s/^IMAGE_TAG=.*/IMAGE_TAG=${PREV_TAG}/" .env; else echo "IMAGE_TAG=${PREV_TAG}" >> .env; fi
            docker compose pull api
            docker compose up -d api
            docker compose ps api
            # Exit non-zero so the CI shows a failed deploy (Slack failure job will notify)
            exit 32
          fi

          echo "✅ Deploy healthy."
          EOSH

  slack-deploy-failure:
    name: Slack notify (deploy failed)
    needs: [notify-start, deploy]
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Post Slack failure message (threaded if possible)
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
          CHANNEL: ${{ needs.notify-start.outputs.channel }}
          THREAD_TS: ${{ needs.notify-start.outputs.thread_ts }}
        run: |
          if [ -n "${SLACK_BOT_TOKEN}" ] && [ -n "${SLACK_CHANNEL_ID}" ] && [ -n "${THREAD_TS}" ]; then
            body=$(jq -n \
              --arg ch "${CHANNEL:-$SLACK_CHANNEL_ID}" \
              --arg ts "$THREAD_TS" \
              --arg t ":warning: *${REPO}* *${TAG}* failed health check and was auto-rolled back. Check CI logs & Grafana/Sentry." \
              '{channel:$ch,text:$t,thread_ts:$ts,unfurl_links:false}')
            curl -s -X POST "https://slack.com/api/chat.postMessage" \
              -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
              -H "Content-type: application/json; charset=utf-8" \
              --data "$body" >/dev/null
            exit 0
          fi
          if [ -n "${SLACK_WEBHOOK}" ]; then
            payload=$(jq -n --arg t ":warning: *${REPO}* deploy of *${TAG}* failed health check and was auto-rolled back. Investigate CI logs & Grafana." '{text:$t}')
            curl -s -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK" >/dev/null
          else
            echo "No Slack creds; skipping failure notify."
          fi

  slack-success:
    name: Slack notify (success)
    needs: [notify-start, api-release, deploy]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Post Slack success message (threaded if possible)
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
          CHANNEL: ${{ needs.notify-start.outputs.channel }}
          THREAD_TS: ${{ needs.notify-start.outputs.thread_ts }}
        run: |
          if [ -z "${SLACK_BOT_TOKEN}" ] || [ -z "${SLACK_CHANNEL_ID}" ]; then
            echo "No Slack bot token/channel; skipping success notify."
            exit 0
          fi
          text=":white_check_mark: *${REPO}* deployed *${TAG}* and passed health checks."
          if [ -n "${THREAD_TS}" ] && [ -n "${CHANNEL}" ]; then
            body=$(jq -n --arg ch "$CHANNEL" --arg ts "$THREAD_TS" --arg t "$text" '{channel:$ch,text:$t,thread_ts:$ts,unfurl_links:false}')
          else
            body=$(jq -n --arg ch "$SLACK_CHANNEL_ID" --arg t "$text" '{channel:$ch,text:$t,unfurl_links:false}')
          fi
          curl -s -X POST "https://slack.com/api/chat.postMessage" \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            -H "Content-type: application/json; charset=utf-8" \
            --data "$body" >/dev/null

  slack-release:
    name: Slack notify
    needs: [api-release, deploy]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
      - name: Post to Slack (Incoming Webhook)
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          REPO: ${{ github.repository }}
          TAG: ${{ github.ref_name }}
        run: |
          if [ -z "${SLACK_WEBHOOK}" ]; then
            echo "No SLACK_WEBHOOK set; skipping Slack notify."
            exit 0
          fi
          payload=$(cat <<JSON
          {
            "text": ":rocket: *${REPO}* deployed *${TAG}* to *production*.\n• Release: https://github.com/${REPO}/releases/tag/${TAG}\n• Image: ghcr.io/${REPO%/*}/spark-api:${TAG}"
          }
          JSON
          )
          curl -s -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK" >/dev/null


